- Current

- ToDo
> norminette libft
	>> add headers
> print (null) if null instead of nothing
> special values for double

- AtExit
> check on makefile if printf sources dont change but libft changes does it recompile
> malloc in ft_atoi/atol etc

- Misc
> fct autorisees : write, malloc, free, exit, stdarg

- ToDo
> what happens when no arg provided but expected an arg
> return the number of characters printed (not including \0 in s)
> if error, return negative value

%[flags][width][.precision][length]type

p : pointer
f  : 
	(floats are converted to double on input)
	double in normal notation, fixed point (works w/ float)
     if no precision, default is 6
	 if decimal point, at least one digit
	  if . or .0, rounded	
	handle 0/-0

length on f
l  : no effect ? 
L  : expect a long double

flags : 
_____________________________________________

#  : alternate forms
	> for f, the output contains a decimal point
	> for o, x and X, prints 0, 0x, 0X in front
0  : when width is specified, prepends 0 instead of sp
-  : left align output
+  : prepend + sign in front of positive numbers (0?)
sp : prepens a ' ' for positive

(order + >> ' ' >> default)

width field :
________________________________________________

In no case does a non-existent or small field width cause truncation of a numeric field; if the result of a conversion is wider than the field width, the field is expanded to contain the conversion result.
minimum char to output
can be numeric
dynamic value is bonus, format is  (%*d", 5, 10) [output '   10']
if leading zero > prepend zeros
if negative value > left align

________________________________________________
precision

a period followed by an optional digit string. no digit string = precision is zero
> minimum number of digits for diouxX
> number of digits after decimal point for (aAeEfF)
> maximum number of char to print from a string
